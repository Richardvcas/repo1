🖥️ Virtual Machine Provisioning via Python + Swagger + GitLab + ArgoCD + OpenShift
This document outlines the end-to-end automation implemented for managing Virtual Machine (VM) lifecycle operations — including Pave, Re-Pave, Resize, and Delete — using a custom Python Flask API, integrated with Swagger UI for input, GitLab for version control, and ArgoCD for deployment into OpenShift.

🔧 Overview
We have automated the VM management lifecycle using a fully self-service API layer that allows controlled provisioning and updates of virtual machines into the OpenShift platform. The solution consists of:

A Python-based API server

Swagger UI for input requests

YAML generation from JSON

GitLab integration for GitOps tracking

ArgoCD integration for deployment into OpenShift

🚀 Operations Supported
Operation	Description
Pave	Fresh VM provisioning using input parameters (e.g., CPU, memory, IP, etc.).
Re-Pave	Redeploy a VM with the same name after removing the previous instance (typically in case of broken states).
Resize	Dynamically update CPU and memory configurations of an existing VM by modifying the YAML in Git and redeploying via ArgoCD.
Delete	Clean removal of the VM by deleting its YAML from GitLab and syncing with ArgoCD to remove it from the cluster.

📑 Workflow Summary
User submits a request via Swagger UI

Input is provided in JSON format (with prefilled default values).

Endpoints: /api/vm-request, /api/vm-resize, /api/vm-delete, /api/vm-repave.

Python Flask backend processes the request

Validates the required fields.

Converts JSON input into a KubeVirt-compliant VM YAML.

Stores the YAML locally.

YAML pushed to GitLab

Each VM is tracked in a Git repository for audit and change history.

Git structure aligns with GitOps best practices.

ArgoCD automatically syncs the updated YAML

ArgoCD detects changes in Git and applies them to the OpenShift cluster.

VMs are created, resized, deleted, or redeployed accordingly.

🔐 Security & Validation
Only allowed fields are editable through Swagger (e.g., CPU, memory in /vm-resize).

Read-only fields like vm_name, namespace are validated in backend logic to prevent tampering.

YAML validation and Git error handling are implemented.

📁 Git Repository Structure
Example:

cpp
Copy
Edit
vm-auto/
  └── data/
        ├── wh-labocp-001.yaml
        ├── wh-labocp-002.yaml
        └── ...
Each file corresponds to a VM. ArgoCD watches this directory and syncs changes.

📷 Screenshots & Demonstration
(Add your screenshots below for Swagger UI, GitLab file pushes, ArgoCD sync status, and OpenShift VM console.)

📌 Future Enhancements
Role-based access for different endpoints

Email notifications on successful operations

Integration with ServiceNow or Jira for request tracking

Support for additional VM parameters (disks, interfaces)

👨‍💻 Contributors
[Your Name]

[Team Members or Reviewers]

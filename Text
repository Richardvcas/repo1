ğŸ§  Virtual Machine Lifecycle Automation via Flask API + Argo CD
ğŸ‘¨â€ğŸ’» Author: Richard Xavier
Date: [Insert date]
Environment: Lab setup (OpenShift without internet access)

ğŸ“ Overview
As part of the VM provisioning automation initiative, I designed and implemented a Flask-based REST API using Python, integrated with Swagger UI, GitLab, and Argo CD. This setup allows users to trigger infrastructure operations such as VM creation, resizing, repaving, and deletion directly from a browser-based interface.

ğŸ§© Technology Stack
Flask (Python)

Swagger UI (flasgger)

GitLab (YAML versioning)

Argo CD (GitOps-based deployment)

OpenShift Virtualization (KubeVirt)

ğŸ“ Project Structure
The API is modular and cleanly structured:

graphql
Copy
Edit
vm-api-project/
â”‚
â”œâ”€â”€ app.py         # Flask app entry point
â”œâ”€â”€ routes.py      # Main API routes for VM operations
â”œâ”€â”€ utils.py       # YAML rendering, Git interaction
â”œâ”€â”€ templates/     # YAML Jinja templates (VM and Job)
â””â”€â”€ data/          # Generated YAMLs before Git push
ğŸ”„ How It Works
Swagger UI is launched via Flask.

The user selects the operation (Pave, Resize, Repave, Delete) and provides inputs via Swagger form.

The input JSON is:

parsed by the Flask API

converted into YAML (based on the selected operation)

YAML is saved locally and then pushed to a GitLab repository.

Argo CD, configured in pull-based sync mode, picks up the new YAML and applies it to OpenShift.

For resize operations, a restart Job YAML is also created and synced to Argo CD.

âœ… Use Cases Implemented
Use Case	Description
Pave	First-time provisioning of VM from base image with config and network setup
Resize	Modify CPU and memory configuration of a running VM
Repave	Replace VM disk/image with a newer base image while preserving config
Delete	Remove the VM definition and associated volumes from GitLab and cluster

ğŸ“· Screenshots of Swagger UI, GitLab YAML, and Argo CD UI will be attached here

ğŸ”§ Highlights
Fully automated GitOps workflow using GitLab + Argo CD.

Internal image used in restart jobs due to no internet access in the lab.

Jobs tagged with argocd.argoproj.io/hook: PostSync to trigger VM restart automatically post-resize.

Error-handling and YAML validation implemented.

Clean modular Python code, making the API extensible.

ğŸ“Œ Notes
All YAML templates were built using Python .format() / Jinja-style placeholders.

The service account and image stream are customized for lab environment with no external internet.

Confluence attachments include:

Swagger UI sample input

GitLab commit snapshot

Argo CD UI in syncing state

Final synced YAMLs

Sample Flask logs

ğŸ“¸ Attachments (To be Added)
 Swagger UI Screenshot

 Sample JSON Input

 Generated YAML

 GitLab YAML commit history

 Argo CD status screen

 Pod/Job logs

ğŸ“‚ Source Code (Snippets Will Be Attached)
You'll find these files embedded with explanation:

app.py

routes.py

utils.py

VM_YAML_TEMPLATE

VM_JOB_YAML_TEMPLATE

Let me know if you want a downloadable Word version or help formatting this in Confluence's page editor.








Ask ChatGPT
You said:
this ok. little more elaborate i will to make long page


ChatGPT said:
Updated saved memory
Perfect! Here's a more elaborate version of the Confluence page content â€” detailed enough to span a full page and suitable for internal documentation or technical sharing.

ğŸ§  Virtual Machine Lifecycle Automation Using Flask API + GitLab + Argo CD
ğŸ‘¨â€ğŸ’» Author: Richard Xavier
Duration: Last 2 Weeks
Environment: Internal OpenShift Lab (No Internet Access)
Tools Used: Python (Flask), GitLab, Argo CD, OpenShift Virtualization

ğŸ“Œ Objective
The primary goal of this project was to automate the lifecycle operations of OpenShift Virtual Machines using a RESTful interface. Users should be able to:

Trigger VM-related actions using a browser

Generate and store YAML definitions in GitLab

Leverage Argo CD to apply the changes in the OpenShift cluster automatically

This approach removes manual YAML handling and enables a GitOps-based VM provisioning and management workflow.

ğŸ§© Tech Stack Breakdown
Component	Purpose
Flask	Lightweight Python web framework used to host the API
Swagger (Flasgger)	Provides a visual interface for users to input VM details
GitLab	Stores YAMLs under version control (manifests managed per namespace)
Argo CD	Syncs YAMLs from GitLab to OpenShift using GitOps
OpenShift Virtualization (KubeVirt)	Platform where the VMs are provisioned and managed

ğŸ”§ Project Structure
The entire solution is built using modular Python files:

graphql
Copy
Edit
vm-api-project/
â”œâ”€â”€ app.py          # Entry point for Flask
â”œâ”€â”€ routes.py       # All Flask API route handlers
â”œâ”€â”€ utils.py        # YAML generation, Git operations
â”œâ”€â”€ templates/      # YAML templates (for VM and Job)
â””â”€â”€ data/           # Temporarily stores generated YAMLs
ğŸŒ How It Works (End-to-End Flow)
Launch Flask App: The API runs locally using Flask with Swagger integrated.

User Input via Swagger: Users interact through Swagger UI to fill in VM details (CPU, Memory, Disk, Image URL, etc.).

JSON â YAML Conversion:

The Python backend converts input JSON into valid Kubernetes YAML (VM definition or Job).

This uses pre-defined templates with placeholders ({vm_name}, {memory}, etc.).

Save YAML to Disk: YAML files are temporarily saved in a local folder (data/).

Push to GitLab: The API automatically pushes the YAML to the appropriate GitLab repo folder (gkp/, gos/, etc.).

Argo CD Auto-Sync:

Argo CD, configured with the Git repo, picks up any YAML changes.

VM gets created or updated accordingly in the OpenShift cluster.

âœ… Implemented Use Cases
Each use case is implemented as a separate API endpoint that follows the above flow:

1. ğŸŸ¢ Pave (Provision a new VM)
Generates a complete VM YAML with boot config, disks, cloud-init secret, and network.

Triggered from /api/vm-request.

2. ğŸŸ¡ Resize
Accepts CPU and Memory updates.

Modifies existing YAML and generates an additional restart Job YAML.

Job uses a PostSync Argo CD hook to restart the VM after resize.

3. ğŸ” Repave
Replaces the image URL in the existing VM YAML (new OS or base version).

Also updates the root disk reference in volumes and dataVolumeTemplates.

4. ğŸ—‘ï¸ Delete
Deletes the YAML file from GitLab via API and triggers removal in the cluster via Argo CD sync.

ğŸ”„ VM Restart (Hook-Based Job YAML)
A Kubernetes Job is generated with the following characteristics:

Uses openshift/cli image

Contains a simple Bash script:

bash
Copy
Edit
oc patch vm <name> -n <namespace> --type=merge -p '{"spec":{"running":false}}'
sleep 15
oc patch vm <name> -n <namespace> --type=merge -p '{"spec":{"running":true}}'
Annotated with:

yaml
Copy
Edit
argocd.argoproj.io/hook: PostSync
argocd.argoproj.io/hook-delete-policy: HookSucceeded
This ensures the Job only runs after Argo CD finishes syncing the updated VM spec.

ğŸ–¼ï¸ Screenshots (To Be Attached)
 Swagger UI showing input form

 GitLab commit with YAML

 Argo CD application panel

 Job status from OpenShift

 VM creation logs

ğŸ“œ Sample APIs
Endpoint	Function
POST /api/vm-request	Create new VM
POST /api/vm-resize	Resize CPU/Memory
POST /api/vm-repave	Update image URL
POST /api/vm-delete	Remove VM YAML

All inputs are provided via Swagger form, and results are automatically pushed to GitLab and synced by Argo CD.

ğŸ’¡ Key Learnings
Argo CD PostSync hooks help automate reboots without manual intervention.

Restart jobs require service account permissions and image stream access in restricted environments.

Without internet access, internal OpenShift image streams must be used.

ğŸ“ Next Steps
Add role-based access to restrict who can trigger which operations.

Add more advanced post-processing logs or monitoring integration.

Explore using Tekton for job chaining in future.

ğŸ§  Conclusion
This implementation has greatly simplified VM lifecycle operations. All the tasks that previously required manual YAML edits and oc apply commands can now be done through an easy-to-use Swagger interface backed by GitOps.

This project is a solid foundation for infrastructure automation in air-gapped OpenShift environments.

Let me know if you want this as a Word or Markdown export for copy-paste into Confluence, or need help formatting the screenshots/codes inline in the page.








✅ 2. Chart.yaml
yaml
Copy
Edit
apiVersion: v2
name: vm-deployment
description: Helm chart to deploy VM in OpenShift Virtualization
version: 0.1.0
✅ 3. values.yaml (example)
yaml
Copy
Edit
vm_name: myvm
namespace: gkp
volume_name: myvm-rootdisk
diskname: myvm-disk
image_url: http://10.14.222.30:8080/rhel-8.10-x86_64-kvm.qcow2
storage_size: 30Gi
status: true
cpu: 4
memory: 8Gi
interface: default
ip: 10.14.21.134
You can duplicate this values.yaml into multiple files (values-gkp.yaml, values-gos.yaml, etc.) for each namespace.

✅ 4. templates/secret.yaml
yaml
Copy
Edit
apiVersion: v1
kind: Secret
metadata:
  name: richard-secret
  namespace: {{ .Values.namespace }}
type: Opaque
stringData:
  userdata: |
    #cloud-config
    runcmd:
      - 'set -x'
      - 'sed -i "/# source INSTALL_CLASS/i generate_fbenv" /usr/local/bin/fb-init.sh'
      ...
    hostname: {{ .Values.vm_name }}
    fqdn: {{ .Values.vm_name }}.wh2.lab.jpmchase.net
    manage_etc_hosts: true
  # add additional write_files block as needed using `tpl` if it includes template variables
✅ 5. templates/pvc.yaml
yaml
Copy
Edit
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ .Values.diskname }}
  namespace: {{ .Values.namespace }}
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: ocs-storagecluster-ceph-rbd-virtualization
✅ 6. templates/vm.yaml
yaml
Copy
Edit
apiVersion: kubevirt.io/v1
kind: VirtualMachine
metadata:
  name: {{ .Values.vm_name }}
  namespace: {{ .Values.namespace }}
spec:
  dataVolumeTemplates:
    - metadata:
        name: {{ .Values.volume_name }}
      spec:
        storage:
          resources:
            requests:
              storage: {{ .Values.storage_size }}
          storageClassName: ocs-storagecluster-ceph-rbd-virtualization
        source:
          http:
            url: {{ .Values.image_url }}
  running: {{ .Values.status }}
  template:
    metadata:
      labels:
        kubevirt.io/vm: {{ .Values.vm_name }}
    spec:
      domain:
        ...
        cpu:
          cores: {{ .Values.cpu }}
        resources:
          requests:
            memory: {{ .Values.memory }}
      networks:
        - name: {{ .Values.interface }}
          multus:
            networkName: default/vlan3702
      volumes:
        ...
        - name: cloudinitdisk
          cloudInitNoCloud:
            secretRef:
              name: richard-secret
            networkData: |
              version: 2
              ethernets:
                eth0:
                  dhcp4: false
                  addresses:
                    - {{ .Values.ip }}
                  gateway4: 10.14.221.129
                  nameservers:
                    addresses:
                      - 10.240.47.3
                      - 10.240.41.3
✅ 7. GitLab + Argo CD Setup
In GitLab repo:

Push the entire vm-helm folder.

Create multiple values files like:

values-gkp.yaml

values-gos.yaml

In Argo CD:

For each VM or namespace, create a separate application.

Example: GKP Application

yaml
Copy
Edit
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: gkp-vm
  namespace: openshift-gitops
spec:
  project: default
  source:
    repoURL: 'https://gitlab.com/yourrepo/vm-helm'
    targetRevision: HEAD
    path: vm-helm
    helm:
      valueFiles:
        - values-gkp.yaml
  destination:
    server: 'https://kubernetes.default.svc'
    namespace: gkp
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
Repeat similarly for gos-vm.

✅ Dynamic Deployment Process
If you're generating values.yaml dynamically via API (like your previous Python code):

Generate values-<vm>.yaml

Push to GitLab

Ensure ArgoCD Application points to that values file
